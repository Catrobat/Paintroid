/**
 *  Paintroid: An image manipulation application for Android.
 *  Copyright (C) 2010-2015 The Catrobat Team
 *  (<http://developer.catrobat.org/credits>)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

def getAdb() {
    def adbPath = android.getAdbExecutable()
    if (System.properties['adbPath']) {
        adbPath = System.properties['adbPath']
    }
    return adbPath.toString()
}

def getAndroidDevices() {
    def deviceIds = []
    [getAdb(), 'devices'].execute().text.eachLine { line ->
        def matcher = line =~ /^(.*)\tdevice/
        if (matcher) {
            deviceIds << matcher[0][1]
        }
    }
    deviceIds
}

def getAndroidDevice() {
    def availableDevices = getAndroidDevices()
    def deviceId
    if (System.properties['deviceId']) {
        deviceId = System.properties['deviceId']
        if (!availableDevices.contains(deviceId))
            throw new IllegalStateException("Device ${deviceId} not found")
    } else {
        if (availableDevices.size() == 0)
            throw new IllegalStateException("No devices found")
        else
            deviceId = availableDevices.first()
    }
    return deviceId.toString()
}

def executeShellCommand(command) {
    println("executing: ${command}")
    def process = new ProcessBuilder(command).redirectErrorStream(true).start()
    process.inputStream.eachLine {println it}
    process.waitFor()
    if(process.exitValue() != 0)
        throw new GradleScriptException("adb exited with exit status ${process.exitValue()}", null)
}

def createAdbInstallTask(variant) {
    task ("commandlineAdbInstall${variant.name.capitalize()}") {
        doLast {
            def command = [getAdb(), '-s', getAndroidDevice(), 'install', variant.outputs[0].outputFile.path]
            executeShellCommand(command)
        }
    }
}

android.applicationVariants.all { variant ->
    createAdbInstallTask(variant)
}

android.testVariants.all { variant ->
    createAdbInstallTask(variant)
}

task commandlineAdbRunTests {
    doLast {
        def command = []
        command.addAll([getAdb(), '-s', getAndroidDevice(), 'shell', 'am', 'instrument', '-w', '-e', 'junitOutputDirectory', '/mnt/sdcard/testresults'])
        if (System.properties['noDeviceTests']){
            command.addAll(['-e', 'notAnnotation', 'org.catrobat.catroid.uitest.annotation.Device'])
        }
        if (System.properties['onlyDeviceTests']){
            command.addAll(['-e', 'annotation', 'org.catrobat.catroid.uitest.annotation.Device'])
        }
        if (System.properties['testClass']){
            command.addAll(['-e', 'class', System.properties['testClass'].toString()])
        }
        if (System.properties['testPackage']){
            command.addAll(['-e', 'package', System.properties['testPackage'].toString()])
        }

        command.addAll(["${android.defaultConfig.testApplicationId}/${android.defaultConfig.testInstrumentationRunner}".toString()])
        executeShellCommand(command)

        def adbPath = project.getBuildDir().getPath()+"/adb"
        def adbTestPath = adbPath+"/test"
        def adbScreenshotsPath = adbPath+"/robotium_screenshots"
        file(adbPath).deleteDir()
        file(adbTestPath).mkdirs()
        file(adbScreenshotsPath).mkdirs()

        def testPullCommand = [getAdb(), '-s', getAndroidDevice(), 'pull', '/sdcard/testresults', adbTestPath]
        def screenshotsPullCommand = [getAdb(), '-s', getAndroidDevice(), 'pull', '/sdcard/Robotium-Screenshots', adbScreenshotsPath]

        executeShellCommand(testPullCommand)
        try {
            executeShellCommand(screenshotsPullCommand)
        } catch (GradleScriptException) {}
    }
}

task adbDisableAnimationsGlobally(type:Exec) {
    description 'Disables android animations globally on the connected device'
    group 'android'

    commandLine android.getAdbExecutable(), 'shell', 'settings', 'put', 'global', 'window_animation_scale', '0.0'
    commandLine android.getAdbExecutable(), 'shell', 'settings', 'put', 'global', 'transition_animation_scale', '0.0'
    commandLine android.getAdbExecutable(), 'shell', 'settings', 'put', 'global', 'animator_duration_scale', '0.0'
}

task adbGrantAnimationScalePermission() {
    description 'Runs "adb shell pm grant" command to grant animation scale permission'
    group 'Permission'

    doLast {
        def adb = android.getAdbExe().toString()
        def deviceId = getAndroidDevice()

        def adbGrantCommand = "${adb} -s ${deviceId} shell pm grant ${android.defaultConfig.applicationId} android.permission.SET_ANIMATION_SCALE"

        logger.info("Granting SET_ANIMATION_SCALE permission to device ${deviceId}")

        logger.debug(adbGrantCommand)

        logger.debug(adbGrantCommand.execute().text)

        logger.debug("Grant done.")
    }
}

task verifyAnimationScalePermissionGranted() {
    description 'Task to verify that SET_ANIMATION_SCALE permission is granted'
    group 'Permission'

    doLast {
        def adb = android.getAdbExe().toString()
        def deviceId = getAndroidDevice()

        def adbCommand = "${adb} -s ${deviceId} shell dumpsys package ${android.defaultConfig.applicationId}"

        def cmdResultText = adbCommand.execute().text

        if(cmdResultText ==~ /(?s).*android.permission.SET_ANIMATION_SCALE(: granted=true|(?s)).*/) {
            logger.info("SET_ANIMATION_SCALE granted on device ${deviceId} for package ${android.defaultConfig.applicationId}.")
        } else {
            def errorMessage = "SET_ANIMATION_SCALE not granted on device ${deviceId} for package ${android.defaultConfig.applicationId}."
            logger.error(errorMessage)
            throw new GradleScriptException(errorMessage, null)
        }
    }
}
