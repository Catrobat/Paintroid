/**
 *  Paintroid: An image manipulation application for Android.
 *  Copyright (C) 2010-2015 The Catrobat Team
 *  (<http://developer.catrobat.org/credits>)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import org.catrobat.gradle.Adb
import org.catrobat.gradle.AndroidDevice
import org.catrobat.gradle.AvdCreator
import org.catrobat.gradle.AvdStore
import org.catrobat.gradle.BootIncompleteExcpetion
import org.catrobat.gradle.DeviceNotFoundException
import org.catrobat.gradle.EmulatorStarter
import org.catrobat.gradle.NoDeviceExcpetion
import org.catrobat.gradle.Utils

Adb adb() {
    new Adb(android.getAdbExecutable())
}

def androidDevice(String androidSerial = null) {
    new AndroidDevice(adb(), androidSerial)
}

/**
 * Ensure that any function here works both on local machines as well as one Jenkins.
 *
 * This is done by setting the needed environment variables.
 */
def determineEnvironment() {
    def env = new HashMap(System.getenv())

    def fallbackEnv = {k, v ->
        if (!env.containsKey(k)) {
            println("ENV: Setting unspecified $k to [$v]")
            env[k.toString()] = v.toString()
        }
    }

    fallbackEnv('ANDROID_AVD_HOME', env['WORKSPACE'] ?: project.rootDir.toPath())

    return env
}

def avdStore() {
    new AvdStore(project.rootDir)
}

def createAdbInstallTask(variant) {
    task ("commandlineAdbInstall${variant.name.capitalize()}") {
        doLast {
            androidDevice().install(variant.outputs[0].outputFile.path)
        }
    }
}

android.libraryVariants.all { variant ->
    createAdbInstallTask(variant)
}

android.testVariants.all { variant ->
    createAdbInstallTask(variant)
}

task commandlineAdbRunTests {
    doLast {
        def device = androidDevice()

        def cmd = device.command(['shell', 'am', 'instrument', '-w', '-e', 'junitOutputDirectory', '/mnt/sdcard/testresults'])
        cmd.addOptionalArguments(System.properties['noDeviceTests'], ['-e', 'notAnnotation', 'org.catrobat.catroid.uitest.annotation.Device'])
        cmd.addOptionalArguments(System.properties['onlyDeviceTests'], ['-e', 'annotation', 'org.catrobat.catroid.uitest.annotation.Device'])
        cmd.addOptionalArguments(System.properties['testClass'], ['-e', 'class', System.properties['testClass'].toString()])
        cmd.addOptionalArguments(System.properties['testPackage'], ['-e', 'package', System.properties['testPackage'].toString()])
        cmd.addArguments(["${android.defaultConfig.testApplicationId}/${android.defaultConfig.testInstrumentationRunner}".toString()])
        cmd.verbose().execute(null)

        def adbPath = project.getBuildDir().getPath() + "/adb"
        file(adbPath).deleteDir()

        def adbTestPath = adbPath + "/test"
        file(adbTestPath).mkdirs()
        device.command(['pull', '/sdcard/testresults', adbTestPath]).verbose().execute()

        try {
            def adbScreenshotsPath = adbPath + "/robotium_screenshots"
            file(adbScreenshotsPath).mkdirs()
            device.command(['pull', '/sdcard/Robotium-Screenshots', adbScreenshotsPath]).verbose().execute()
        } catch (GradleScriptException) {}
    }
}

task adbDisableAnimationsGlobally() {
    description 'Disables android animations globally on the connected device'
    group 'android'

    doLast {
        logger.lifecycle(description)
        androidDevice().disableAnimationsGlobally()
    }
}

task adbResetAnimationsGlobally() {
    description 'Reset android animations globally on the connected device'
    group 'android'

    doLast {
        logger.lifecycle(description)
        androidDevice().resetAnimationsGlobally()
    }
}

def reuseOrCreateAvd() {

        def avdCreator = new AvdCreator(android.sdkDirectory, avdStore())
        avdCreator.apply {
            systemImage = 'system-images;android-24;default;x86_64'
            sdcardSizeMb = 200
            addProperties(['hw.ramSize': 800, 'vm.heapSize': 128])
            screenDensity = 'xhdpi'
        }
        avdCreator.reuseOrCreateAvd(determineEnvironment())
}

def reuseRunningOrStartEmulator() {
    def proc
    def device

    try {
        // try to access an already running emulator
        device = androidDevice()
    } catch (DeviceNotFoundException e) {
        // A specific deivce was specified that does not exist
        throw e
    } catch (NoDeviceExcpetion) {
        // no device running, start one
        println('Start the emulator!')

        def emulatorStarter = new EmulatorStarter(android.sdkDirectory, {
            showWindow = !Utils.isRunningOnJenkins()
            resolution = '768x1280'
            language = 'en'
            country = 'US'
        })

        proc = emulatorStarter.start(avdStore().readAvdName(), determineEnvironment())

        try {
            device = androidDevice(adb().waitForSerial())
        } catch(NoDeviceExcpetion e) {
            proc.waitForOrKill(1)
            throw e
        }
    }

    try {
        println("Using device ${device.androidSerial}")
        device.waitForBooted()
    } catch (BootIncompleteExcpetion e) {
        proc?.waitForOrKill(1)
        throw e
    }
}

task startEmulator() {
    description 'Starts the android emulator'
    group 'android'

    doLast {
        reuseOrCreateAvd()
        reuseRunningOrStartEmulator()
    }
}

task retrieveLogcat() {
    description 'Retrieves the logcat.txt from the device.'
    group 'android'

    doLast {
        def device = androidDevice()
        def logcat = new File(project.rootDir, 'logcat.txt')
        device.writeLogcat(logcat)
    }
}

task stopEmulator() {
    description 'Stops the android emulator'
    group 'android'

    doLast {
        try {
            def device = androidDevice()
            device.command(['emu', 'kill']).verbose().execute()
            device.waitForStopped()
        } catch (NoDeviceException) {
            // already stopped
        }
    }
}
